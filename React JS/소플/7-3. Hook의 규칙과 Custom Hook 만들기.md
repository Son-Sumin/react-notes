## 7. Hooks   
### 7-3. Hook의 규칙과 Custom Hook 만들기   

- **Hook의 규칙**   
  * Hook은 단순한 자바스크립트 함수이지만 2가지 규칙이 있음   
    **1. Hook은 무조건 최상위 레벨에서만 호출해야 한다.**   
       - 최상위 레벨: 리액트 함수 컴포넌트의 최상위 레벨   
       - 따라서 반복문, 조건문, 또는 중첩된 함수들 안에서 Hook을 호출하면 안됨   
       - Hook은 컴포넌트가 렌더링될 때마다 매번 같은 순서로 호출되어야 한다.   
         이렇게 해야 리액트가 다수의 useState Hook, useEffect Hook을 호출해서 컴포넌트 state를 올바르게 관리 가능함   
         ``` JavaScript
         // 잘못된 Hook 사용법
         // 렌더링할 때마다 Hooks이 같은 순서로 호출되는 것이 아니라 if문 결과에 따라 호출되는 Hooks이 달라지므로 
         function MyComponent(props) {
          const [name, setName] = useState('Waffle');

          if (name !== '') {
            useEffect(() => {
              ...
            });
          }
         }
         ```
         <br>
    **2. 리액트 함수 컴포넌트에서만 Hook을 호출해야 한다.**   
       - 일반 자바스크립트 함수에서 Hook을 호출하면 안됨   
       - 리액트 함수 컴포넌트 또는 직접 만든 커스컴 Hook에서만 호출 가능함   
       - 이 규칙에 따라 리액트 컴포넌트에 있는 state와 관련된 모든 로직은 소스코드를 통해 명확하게 확인 가능해야함   
       <br>

- **eslint-plugin-react-hooks**   
  * 개발에 도움이 되는 패키지, eslint의 plugin   
  * Hook의 규칙을 따르도록 강제해주는 plugin   
  * eslint : 자바스크립트 코드에서 발견되는 문제 패턴을 식별하기 위한 정적 코드 분석 도구   
  * eslint-plugin-react-hooks은 의존성 배열이 잘못 되어있는 경우 자동으로 경고 표지, 고칠방법 제안해줌   
  * 참고 : https://www.npmjs.com/package/eslint-plugin-react-hooks   
   ``` JavaScript
    /* useMemo()에서 의존성 배열에 넣은 변수들은 create함수의 파라미터들로 전달되지 않음
    // useMemo() Hook의 원래 의미가 의존성 배열의 변수 중 하나라도 변하면 create함수를 다시 호출하는 것이기 때문에
    // create함수에서 창조하는 모든 변수를 의존성 배열에 넣어주는 것이 맞음
    // 후에 컴파일러가 개선되어 이런 의존성 배열을 자동으로 생성할 수 있게 될 것임
    // 하지만 지금은 직접 의존성 배열을 만들어주는 것이 중요함 
    // 이를 위해 eslint-plugin-react-hooks 패키지를 사용하면 도움됨
    */
   
    const memoizdValue = useMemo(
      () => {
        // 연산량이 높은 작업을 수행하여 결과를 반환
        return computeExpensiveValue(의존성 변수1, 의존성 변수2);
      },
      [의존성 변수1, 의존성 변수2]
    );
    ```
    <br>

- **Custom Hook 만들기**  
  * 리액트에서 기본 제공되는 Hook 이외에 추가 필요 기능이 있다면 직접 Hook을 만들어 사용 가능함   
  * Custom Hook을 만드는 이유 : 여럼 컴포넌트에서 반복 사용하는 로직을 Hook으로 만들어 재사용하기 위함   
  * Custom Hook을 만들어야 하는 상황   
  ```
    - UserStatus라는 컴포넌트는 isOnline이라는 status에 따라서 사용자의 상태의 온라인 여부를 텍스트로 보여줌   
    - 동일한 웹사이트에서 연락처 목록을 제공하는데 이때 온라인 사용자 이름은 초록색으로 표시   
      이 컴포넌트 이름을 userListItem이라 하고 UserStatus와 비슷한 로직 필요   
    - 기존 리액트에서는 보통 state와 관련 로직이 중복될 시 higher-order-component를 사용했음   
    - 여기서는 중복된 코드를 추출하여 Custom Hook으로 만드는 새로운 방법을 사용해보자
  ```
    <그림1 2>
  <br>

  * Custom Hook 추출하기   
    - **Custom Hook : 이름이 use로 시작하고 내부에서 다른 Hook을 호출하는 하나의 자바스크립트 함수**   
    - 2개의 자바스트립트 함수에서 하나의 로직을 공유하고 싶을 때 새로운 함수를 하나 만듦   
    - 리액트 함수 컴포넌트와 Hook은 함수이기 때문에 동일한 방법 사용 가능   
    <그림3>

    - 중복되는 로직을 useUserStatus라는 Custom Hook으로 추출함   
    - 다른 컴포넌트 내부에서와 마찬가지로 다른 Hook을 호출하는 것은 무조건 Custom Hook의 최상위 레벨에서 해야함   
    - 리액트 컴포넌트와 달리 Custom Hook은 특별한 규칙이 없음 (파라미터, 리턴값 모두 개발자가 직접 지정 가능)   
    - Custom Hook은 단순한 함수와 같고, 앞에 use를 붙여 리액트 Hook임을 알려주는 것   
      Hook이기에 위의 2가지 규칙 적용됨   

  * Custom Hook 사용하기   
    - 